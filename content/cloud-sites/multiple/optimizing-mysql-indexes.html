---
node_id: 686
title: Optimizing MySQL - Indexes
permalink: article/optimizing-mysql-indexes
type: article
created_date: '2011-03-16 21:57:40'
created_by: RackKCAdmin
last_modified_date: '2011-09-07 16:4844'
last_modified_by: test_stakeholder
products: Cloud Sites
categories: 'Linux MySQL,Performance'
body_format: tinymce
---

<!-- start content --><p><strong>Importance of using Indexes in your MySQL database:</strong></p><p>Indexes help the system to access data fast and provide an ordering on the rows of a table as well as help enforce uniqueness of the values in a table. A lot of performance problems occur in Cloud Sites for database queries when customers have not created the necessary indexes on their tables. To look into how to create an index in MySQL, please refer to:</p><dl><dd><a href="http://dev.mysql.com/doc/refman/5.0/en/create-index.html" title="http://dev.mysql.com/doc/refman/5.0/en/create-index.html" class="external free" rel="nofollow">http://dev.mysql.com/doc/refman/5.0/en/create-index.html</a></dd></dl><p><a name="The_Explain_Statement" id="The_Explain_Statement"></a></p><h2><span class="mw-headline">The Explain Statement</span></h2><p>The best way to analyze your query and to see if indexes are being used is by running an explain plan on it. This will show you the path chosen by the optimizer in executing the query and help give you an idea as to whether or not you will benefit from creating an index. More on the explain plan here:</p><dl><dd><a href="http://dev.mysql.com/doc/refman/5.0/en/explain.html" title="http://dev.mysql.com/doc/refman/5.0/en/explain.html" class="external free" rel="nofollow">http://dev.mysql.com/doc/refman/5.0/en/explain.html</a></dd></dl><p><a name="Prefixing_index_lengths_with_an_example" id="Prefixing_index_lengths_with_an_example"></a></p><h2><span class="mw-headline">Prefixing index lengths with an example</span></h2><p>Say you run this SQL frequently:</p><pre>SELECT user_id, user_id AS ID, user_login, display_name, user_email, meta_value FROM insider_users,
 usermeta WHERE insider_users.ID = usermeta.user_id AND meta_key = 'S' ORDER BY usermeta.user_id;</pre><p>Say you have this table:</p><pre>CREATE TABLE `usermeta` ( `umeta_id` bigint(20) unsigned NOT NULL auto_increment, `user_id` bigint
(20) unsigned NOT NULL default '0', `meta_key` varchar(255) default NULL, `meta_value` longtext, PRIMARY KEY 
(`umeta_id`), KEY `user_id` (`user_id`), KEY `meta_key` (`meta_key`) ENGINE=InnoDB AUTO_INCREMENT=25199 
DEFAULT CHARSET=utf8</pre><p>For table usermeta table above, the original meta_key index that is varchar(255).</p><dl><dd><ul><li><strong>Note the meta_key index - When you index a full and large column like this, then you will hurt your performance.</strong></li></ul></dd></dl><p>What would benefit this query is prefixing the length - dropping the meta_key index and then re-creating an index but at prefix length of 20. Doing this helps gain performance and saves space. This also reduces disk IO which buys your faster performance also.</p><p><a name="Covering_Index" id="Covering_Index"></a></p><h2><span class="mw-headline">Covering Index</span></h2><p><strong>The following is an example of a slow MySQL query which also does not have an Index(s) in place:</strong></p><pre># Query_time: 82.420792  Lock_time: 0.015179  Rows_sent: 1  Rows_examined: 15828351  Rows_affected: 0  Rows_read: 15828351
use 393870_p2LIVE; SELECT `Impression`.`id`, `Impression`.`account_id`, `Impression`.`content_id`, `Impression`.`networks_id`, 
`Impression`.`ip`, `Impression`.`recorded` FROM `impressions` AS `Impression`   WHERE `account_id` = 222 AND `content_id` = 19 AND `networks_id` = 8</pre><!-- 
NewPP limit report
Preprocessor node count: 13/1000000
Post-expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Expensive parser function count: 0/100
--><!-- Saved in parser cache with key cswiki:pcache:idhash:397-0!1!0!!en!2!edit=0 and timestamp 20110324165533 --><div class="printfooter">&nbsp;</div><!-- end content -->
